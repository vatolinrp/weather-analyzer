http://www.ehcache.org/generated/2.9.0/html/ehc-all/#page/Ehcache_Documentation_Set%2Fco-over_what_is_ehcache.html%23

2 Ehcache

2.1 Введение в Ehcache

Ehcache - основанный на стандартах кеш с открытым исходным кодом. Создан для повышения производительности, разгрузки баз данных и упрощения масштабирования программного продукта. Являясь надежным, проверенным и полнофункциональным решением, он наиболее широко используем на сегодняшний день в приложениях, написанных на Java. Можно использовать Ehcache как кеш общего назначения или как кэш второго уровня для Hibernate. Также можно дополнительно интегрировать его с продуктами сторонних производителей, такими как ColdFusion, Google App Engine и Spring.
Ehcache предоставляет кэш в процессе, который можно реплицировать на нескольких узлах. Он также лежит в основе BigMemory Go и BigMemory Max, коммерческого кэширования Terracotta и хранения данных в памяти. Массив Terracotta Server Array, поставляемый с BigMemory Max, позволяет использовать смешанные конфигурации в процессе или вне процесса с кэшами размером в терабайт.

2.2 Терминология

Cache - Википедия определяет этот термин как “a store of things that will be required in the future, and can be retrieved rapidly.”, что в переводится как хранилище вещей, которые потребуются в будущем, и которые могут быть быстро извлечены. Сам по себе кэш представляет собой набор временных данных, которые либо дублируют данные, расположенные в другом месте, либо являются результатом вычисления. Данные, которые уже находятся в кэше, могут быть повторно доступны с минимальными затратами с точки зрения времени и ресурсов.

Cache hit - когда элемент данных запрашивается из кэша и он существует для данного ключа, то это случай носит название “кэш попадание” ( cache hit ).

Cache miss - когда элемент данных запрашивается из кэша и он не существует для данного ключа, то данный случай носит название “кэш промах“ ( cache miss ).

System of Record ( SOR ) - источник кэшированных данных. Кэш действует как локальное хранилище копий данных, полученных или сохраненных в системе записи (SOR). SOR часто является традиционной базой данных, хотя это может быть специализированная файловая система или какое-либо другое надежное долговременное хранилище. Работая с Ehcache, предполагается, что в качестве SOR используется база данных.

Standalone cache topology - автономная кэш топология, при которой данные хранятся в узле приложения. Любые другие узлы приложения независимы, между ними нет связи. Если используется автономная топология, когда несколько узлов используют одно и то же приложение, то между ними существует слабая согласованность. Они содержат согласованные значения для неизменяемых данных или обновляют элемент данных после того, как время жизни элемента завершилось.

Distributed cache topology - распределенная кэш топология, данные хранятся на удаленном сервере ( или кластере серверов ) с поднабором недавно используемых данных, хранящихся в каждом узле приложения. Эта топология предлагает богатый набор параметров для согласованности. Распределенная топология является рекомендуемым подходом в кластерной или масштабируемой прикладной среде. Она обеспечивает высочайший уровень производительности, доступности и масштабируемости. Распределенная топология доступна только с BigMemory Max.

Replicated cache topology - реплицированная кэш топология, кэшированный набор данных хранится в каждом узле приложения, и данные копируются или недействительны по узлам без блокировки. Репликация может быть асинхронной или синхронной, где поток записи блокируется во время распространения. Единственный режим согласованности, поддерживаемый в этой топологии, - «Слабая согласованность». Многие производственные приложения развертываются в кластерах из нескольких экземпляров для обеспечения доступности и масштабируемости. Однако без распределенного или реплицированного кеша кластеры приложений демонстрируют ряд нежелательных действий, таких как cache drift и database bottlenecks.

Cache Drift - в этом случае, каждый экземпляр приложения хранит свой собственный кеш. Обновления, сделанные в одном кэше, не будут отображаться в других экземплярах. Это происходит с данными веб-сессии. Распределенная или реплицированная топологии кэша обеспечивает синхронизацию всех экземпляров кэша друг с другом.

Database Bottlenecks - узкие места в базе данных. В одиночном экземпляре приложения, кеш эффективно защищает базу данных от избыточных запросов. Однако в распределенной среде приложений каждый экземпляр имеет большую нагрузку и обновляет свой собственный кеш. Издержки при загрузке и обновлении нескольких кэшей приводят к узким местам базы данных по мере добавления большего количества экземпляров приложений. Распределенный или реплицированный кеш устраняет накладные расходы для каждого экземпляра загрузки и обновления нескольких кэшей из базы данных.

Locality of reference - В информатике  - местность ссылки, также известная как принцип локальности, является термином для явления, в котором часто используются одни и те же значения или связанные с ним места хранения, в зависимости от шаблона доступа к памяти. Существует два основных типа эталонного местоположения - временная и пространственная локальность. Временная локальность относится к повторному использованию определенных данных и / или ресурсов в течение относительно небольшой продолжительности времени. Пространственная локальность относится к использованию элементов данных в относительно близких местах хранения. Последовательная локальность - частный случай пространственной локальности - возникает, когда элементы данных упорядочиваются и получают линейный доступ, например, обход элементов в одномерном массиве.

2.3 Уровни хранения данных

Вы можете разделить кэш или данные в памяти в следующих областях хранения, называемых уровнями:
1) MemoryStore - память в куче, используемая для хранения элементов кэша. Этот уровень может быть подвержен сборке мусора со стороны Java. Хранилище памяти всегда включено и существует в куче памяти. Оно принимает все данные, будь-то сериализуемые они или нет. Также стоит упомянуть, что это самый быстрый вариант хранения и является потокобезопасным для использования несколькими параллельными потоками. Если вы используете OffHeapStore (доступен только в продуктах BigMemory), MemoryStore хранит копию самого горячего подмножества данных из OffHeapStore.
Все кеши определяют максимальный размер в памяти, с точки зрения количества элементов, во время настройки. Когда элемент добавляется в кеш и выходит за пределы его максимального объема памяти, существующий элемент либо удаляется, если переполнение не активировано, либо оценивается для буферизации на другом уровне, если переполнение включено. Если переполнение включено, выполняется проверка на истечение срока действия хранимых данных. Если срок вышел, то он удаляется, иначе он остается сохраненным, но в отдельном месте.

2) OffHeapStore - предоставляет возможность переполнения памяти MemoryStore. Ограничено по размеру только доступной оперативной памятью. Не подлежит сборке мусора Java (GC). Доступно только для продуктов Terracotta BigMemory. OffHeapStore расширяет кеш к памяти за пределами кучи Java. Этот хранилище, не подлежит воздействию со стороны сборщика мусора Java (GC), ограничено только объемом доступной памяти. Используя OffHeapStore, можно создавать очень большие локальные кеши. OffHeapStore доступен только для продуктов Terracotta BigMemory.
Поскольку данные вне кучи хранятся в байтах, только данные, которые являются Serializable, подходят для OffHeapStore. Любые несериализуемые данные, переполняемые в OffHeapMemoryStore, просто удаляются, и выдается сообщение логгера уровня WARNING. Поскольку сериализация и десериализация происходят при переносе и получении из хранилища не-кучи, теоретически она медленнее, чем MemoryStore. Однако это различие смягчается, когда учитывается сборка мусора, связанная с большими кучами. Для достижения наилучшей производительности рекомендуется выделять для кэша как можно больше памяти кучи, не запуская GC-паузы. Затем используйте OffHeapStore для хранения данных, которые не умещаются в куче (не вызывая GC-паузы).

3) DiskStore - создает резервные копии элементов кэша в памяти и обеспечивает переполнение для других уровней. DiskStore обеспечивает потокобезопасное средство буферизации дисков, которое может быть использовано для дополнительного хранения или сохранения данных при перезагрузке системы. Стоит заметить, что уровень DiskStore доступен только для локальных (автономных) экземпляров кэша. Когда вы используете распределенный кеш (доступный только в BigMemory Max), Terracotta Server Array используется вместо уровня диска. Только данные Serializable могут быть помещены в DiskStore. Записывает и использует диск ObjectInputStream и механизм сериализации Java. Любые несериализуемые данные, переполняющие хранилище на диске, удаляются и генерируется исключение NotSerializableException. Стоить иметь в виду, что на скорость сериализации влияет размер сериализуемых объектов и их тип. Например, было показано, что время сериализации для Java-объекта, состоящего из большого массива Map String, составляет около 126 мс, где сериализованный размер получается 349,225 байт. Также время сериализации для массива байтов составило 7 мс, где сериализованный размер около 310,232 байта. Байт-массивы в 20 раз быстрее сериализовать, что делает их лучшим выбором для повышения производительности дискового хранилища. Конфигурирование хранилища дисков не является обязательным. Если все кэши используют только память и хранилища не-кучи, нет необходимости настраивать хранилище дисков. Это упрощает настройку и использует меньше потоков.

2.4 Улучшения производительности

Хоть, Ehcache относится к объектам Java, кэширование используется во всех вычислениях, от кэшей ЦП до системы доменных имен в Интернете (DNS). Это происходит из-за того, что многие компьютерные системы показывают «местность ссылки». Данные, которые находятся рядом с другими данными или недавно использовались, с большей вероятностью будут использоваться снова.
[картинка]
Длинный хвост
Крис Андерсон из Wired Magazine придумал термин «длинный хвост» для обозначения случаев в системах электронной коммерции, где небольшое количество товаров может составлять основную часть продаж (или небольшое количество блогов может получить наибольшее количество обращений). И как следствие есть длинный «хвост» менее популярных предметов. Длинный хвост является примером закона силы распределения вероятности, такого как распределение Парето или правило 80:20. Если 20 процентов объектов используется в 80 процентах случаев и можно найти способ снизить затраты на получение этих 20 процентов, производительность системы улучшится.

Стоит задать вопрос о том, на сколько приложение получает преимущество от кэширования. Преимущество особенно заметно, когда есть работа с вводом-выводом и есть нужда в скорости, с которой данные могут быть получены. Если же имеем дело с CPU, тогда время зависит от скорости центрального процессора и основной памяти. Кэширование обычно повышает производительность и снижает нагрузку на веб-сервер.

Приложения с плотной привязкой к CPU, часто ускоряются за счет:

1) улучшения производительности алгоритма;
2) распараллеливания вычислений между несколькими процессорами (SMP) или несколькими машинами (кластерами);
3) увеличения скорости процессора.

Кэш может временно хранить вычисления для повторного использования, включая, но не ограничиваясь большими веб-страницами с высокой стоимостью рендеринга или состояниями аутентификации, когда аутентификация требует криптографических преобразований.

Многие приложения связаны с операциями ввода-вывода, либо дисковыми или сетевыми операциями. В случае баз данных они могут быть ограничены обоими.
Для жестких дисков нет закона Мура. 10 000 оборотов в минуту были быстрыми 10 лет назад и по-прежнему быстры. Жесткие диски ускоряются, используя собственное кэширование блоков в память.

Сетевые операции могут быть замедленны благодаря следующим факторам:
1) время для установки и разрыва соединения
2) задержка, или минимальное время прохода туда и обратно
3) пределы пропускной способности
4) временные затраты на преобразования

Кэширование является распространенным выходом для повышения производительности приложений, особенно тех, которые постоянно выполняют операции по вводу-выводу. Ehcache очень удобно использовать для кэширования объекта доступа к данным для Hibernate или для кэширования веб-страниц, для страниц, созданных из баз данных.

Следствием повышения производительности является повышенная масштабируемость. Если предположим, что у нас есть база данных, которая может выполнять до 100 дорогих запросов в секунду. Помимо этого порога база данных резервирует запросы, и если возникают дополнительные соединения, производительность работы с базой данных медленно падает. В этом случае кэширование, вероятно, уменьшит рабочую нагрузку. Если кэширование может привести к тому, что 90% из этих 100 будут хитами кэша и не повлияют на базу данных, база данных может масштабироваться в 10 раз.
