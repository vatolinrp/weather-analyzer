http://www.ehcache.org/generated/2.9.0/html/ehc-all/#page/Ehcache_Documentation_Set%2Fco-over_what_is_ehcache.html%23

2 Ehcache

2.1 Введение в Ehcache

Ehcache - основанный на стандартах кеш с открытым исходным кодом. Создан для повышения производительности, разгрузки баз данных и упрощения масштабирования программного продукта. Являясь надежным, проверенным и полнофункциональным решением, он наиболее широко используем на сегодняшний день в приложениях, написанных на Java. Можно использовать Ehcache как кеш общего назначения или как кэш второго уровня для Hibernate. Также можно дополнительно интегрировать его с продуктами сторонних производителей, такими как ColdFusion, Google App Engine и Spring.
Ehcache предоставляет кэш в процессе, который можно реплицировать на нескольких узлах. Он также лежит в основе BigMemory Go и BigMemory Max, коммерческого кэширования Terracotta и хранения данных в памяти. Массив Terracotta Server Array, поставляемый с BigMemory Max, позволяет использовать смешанные конфигурации в процессе или вне процесса с кэшами размером в терабайт.

2.2 Терминология

Cache - Википедия определяет этот термин как “a store of things that will be required in the future, and can be retrieved rapidly.”, что в переводится как хранилище вещей, которые потребуются в будущем, и которые могут быть быстро извлечены. Сам по себе кэш представляет собой набор временных данных, которые либо дублируют данные, расположенные в другом месте, либо являются результатом вычисления. Данные, которые уже находятся в кэше, могут быть повторно доступны с минимальными затратами с точки зрения времени и ресурсов.

Cache hit - когда элемент данных запрашивается из кэша и он существует для данного ключа, то это случай носит название “кэш попадание” ( cache hit ).

Cache miss - когда элемент данных запрашивается из кэша и он не существует для данного ключа, то данный случай носит название “кэш промах“ ( cache miss ).

System of Record ( SOR ) - источник кэшированных данных. Кэш действует как локальное хранилище копий данных, полученных или сохраненных в системе записи (SOR). SOR часто является традиционной базой данных, хотя это может быть специализированная файловая система или какое-либо другое надежное долговременное хранилище. Работая с Ehcache, предполагается, что в качестве SOR используется база данных.

Standalone cache topology - автономная кэш топология, при которой данные хранятся в узле приложения. Любые другие узлы приложения независимы, между ними нет связи. Если используется автономная топология, когда несколько узлов используют одно и то же приложение, то между ними существует слабая согласованность. Они содержат согласованные значения для неизменяемых данных или обновляют элемент данных после того, как время жизни элемента завершилось.

Distributed cache topology - распределенная кэш топология, данные хранятся на удаленном сервере ( или кластере серверов ) с поднабором недавно используемых данных, хранящихся в каждом узле приложения. Эта топология предлагает богатый набор параметров для согласованности. Распределенная топология является рекомендуемым подходом в кластерной или масштабируемой прикладной среде. Она обеспечивает высочайший уровень производительности, доступности и масштабируемости. Распределенная топология доступна только с BigMemory Max.

Replicated cache topology - реплицированная кэш топология, кэшированный набор данных хранится в каждом узле приложения, и данные копируются или недействительны по узлам без блокировки. Репликация может быть асинхронной или синхронной, где поток записи блокируется во время распространения. Единственный режим согласованности, поддерживаемый в этой топологии, - «Слабая согласованность». Многие производственные приложения развертываются в кластерах из нескольких экземпляров для обеспечения доступности и масштабируемости. Однако без распределенного или реплицированного кеша кластеры приложений демонстрируют ряд нежелательных действий, таких как cache drift и database bottlenecks.

Cache Drift - в этом случае, каждый экземпляр приложения хранит свой собственный кеш. Обновления, сделанные в одном кэше, не будут отображаться в других экземплярах. Это происходит с данными веб-сессии. Распределенная или реплицированная топологии кэша обеспечивает синхронизацию всех экземпляров кэша друг с другом.

Database Bottlenecks - узкие места в базе данных. В одиночном экземпляре приложения, кеш эффективно защищает базу данных от избыточных запросов. Однако в распределенной среде приложений каждый экземпляр имеет большую нагрузку и обновляет свой собственный кеш. Издержки при загрузке и обновлении нескольких кэшей приводят к узким местам базы данных по мере добавления большего количества экземпляров приложений. Распределенный или реплицированный кеш устраняет накладные расходы для каждого экземпляра загрузки и обновления нескольких кэшей из базы данных.

2.3 Уровни хранения данных
Вы можете разделить кэш или данные в памяти в следующих областях хранения, называемых уровнями:
1) MemoryStore - память в куче, используемая для хранения элементов кэша. Этот уровень может быть подвержен сборке мусора со стороны Java. Хранилище памяти всегда включено и существует в куче памяти. Оно принимает все данные, будь-то сериализуемые они или нет. Также стоит упомянуть, что это самый быстрый вариант хранения и является потокобезопасным для использования несколькими параллельными потоками. Если вы используете OffHeapStore (доступен только в продуктах BigMemory), MemoryStore хранит копию самого горячего подмножества данных из OffHeapStore.
Все кеши определяют максимальный размер в памяти, с точки зрения количества элементов, во время настройки. Когда элемент добавляется в кеш и выходит за пределы его максимального объема памяти, существующий элемент либо удаляется, если переполнение не активировано, либо оценивается для буферизации на другом уровне, если переполнение включено. Если переполнение включено, выполняется проверка на истечение срока действия хранимых данных. Если срок вышел, то он удаляется, иначе он остается сохраненным, но в отдельном месте.

2) OffHeapStore - предоставляет возможность переполнения памяти MemoryStore. Ограничено по размеру только доступной оперативной памятью. Не подлежит сборке мусора Java (GC). Доступно только для продуктов Terracotta BigMemory. OffHeapStore расширяет кеш к памяти за пределами кучи Java. Этот хранилище, не подлежит воздействию со стороны сборщика мусора Java (GC), ограничено только объемом доступной памяти. Используя OffHeapStore, можно создавать очень большие локальные кеши. OffHeapStore доступен только для продуктов Terracotta BigMemory.
Поскольку данные вне кучи хранятся в байтах, только данные, которые являются Serializable, подходят для OffHeapStore. Любые несериализуемые данные, переполняемые в OffHeapMemoryStore, просто удаляются, и выдается сообщение логгера уровня WARNING. Поскольку сериализация и десериализация происходят при переносе и получении из хранилища не-кучи, теоретически она медленнее, чем MemoryStore. Однако это различие смягчается, когда учитывается сборка мусора, связанная с большими кучами. Для достижения наилучшей производительности рекомендуется выделять для кэша как можно больше памяти кучи, не запуская GC-паузы. Затем используйте OffHeapStore для хранения данных, которые не умещаются в куче (не вызывая GC-паузы).

3) DiskStore - создает резервные копии элементов кэша в памяти и обеспечивает переполнение для других уровней. DiskStore обеспечивает потокобезопасное средство буферизации дисков, которое может быть использовано для дополнительного хранения или сохранения данных при перезагрузке системы. Стоит заметить, что уровень DiskStore доступен только для локальных (автономных) экземпляров кэша. Когда вы используете распределенный кеш (доступный только в BigMemory Max), Terracotta Server Array используется вместо уровня диска. Только данные Serializable могут быть помещены в DiskStore. Записывает и использует диск ObjectInputStream и механизм сериализации Java. Любые несериализуемые данные, переполняющие хранилище на диске, удаляются и генерируется исключение NotSerializableException. Стоить иметь в виду, что на скорость сериализации влияет размер сериализуемых объектов и их тип. Например, было показано, что время сериализации для Java-объекта, состоящего из большого массива Map String, составляет около 126 мс, где сериализованный размер получается 349,225 байт. Также время сериализации для массива байтов составило 7 мс, где сериализованный размер около 310,232 байта. Байт-массивы в 20 раз быстрее сериализовать, что делает их лучшим выбором для повышения производительности дискового хранилища. Конфигурирование хранилища дисков не является обязательным. Если все кэши используют только память и хранилища не-кучи, нет необходимости настраивать хранилище дисков. Это упрощает настройку и использует меньше потоков.


